import sys
import os
import time
# -*- coding: utf-8 -*-
"""Compilador.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1snaUx0SvAZvcMyPhfb6-A55NPUVfayVj
"""

#Tipos de tags e suas numerações (Estamos usando os 255 caracteres da tabela ASCII)
STRING = 256
MAIIGU = 257
MENIGU = 258
COMP = 259
DIF = 260
INT = 261
FLUT = 262
RES = 263
ID = 264

palavrasReservadas = ['se', 'senao', 'para', 'enquanto', 'funcao', 'inteiro', 'flut', 'variaveis', 'algoritmo', 'cadeia', 'retorne']
class Token():
  def classifier(self, valor, tipo):
    if tipo == -1:
      return -1
    elif tipo == 77: #Quer dizer que o valor do token é uma string feita com aspas
      return STRING#STRING
    else:
      if tipo == 3:
        if len(valor) == 1:
          return ord(valor)
        else:
          if valor[1]=='>':
            return MAIIGU#maiororigual
          else:
            if valor[1]=='<':
              return MENIGU#menororigual
            else:
              if valor[1]=='=':
                return COMP#compare
              else:
                return DIF#diferente
      else:
        if tipo == 0:
          return INT#inteeiro
        else:
          if tipo==1:
            return FLUT#float
          else:
            for palavra in palavrasReservadas:
              if palavra.lower() == valor.lower():
                return RES#palavraReservada
            return ID#identificador ou variavel

  def __init__(self, valor, tipo, flag=0):
    if flag == 1:
      self.tipo = tipo
    else:
      self.tipo = self.classifier(valor, tipo)
    self.valor = valor

  def toString(self):
    print("<"+str(self.tipo)+","+str(self.valor)+">")

class lexicografo():
  def __init__(self, nArquivo):
    self.pos = 0 #Posiçao que o lexicógrafo está lendo no estado atual do programa
    self.flagEOL = 1
    self.arquivo = open(nArquivo, 'r')
    self.linha = None
    self.tamLinha = 0
    self.linhaAtual = 0
    self.tokenVazio = Token("Ignore", -1)

  def getLinhaAtual(self):
    return self.linhaAtual

  def scan(self):
    buffer = ""
    tipo = None
    if self.flagEOL == 1 or self.linha == None:
      self.linha = self.arquivo.readline()
      self.tamLinha = len(self.linha)
      if len(self.linha.replace("\n", "").replace(" ", "")) == 0:
        self.linha = self.arquivo.readline()
        self.tamLinha = len(self.linha)
      self.pos = 0
      self.flagEOL = 0
    while self.linha:
      if self.linha[self.pos].isspace():
        while self.linha[self.pos].isspace() and self.pos < self.tamLinha-1:
          self.pos = self.pos + 1
      if self.linha[self.pos].isdigit():
        buffer = 0
        while self.linha[self.pos].isdigit():
          buffer = int(buffer)*10 + int(self.linha[self.pos])
          self.pos = self.pos + 1
        if self.linha[self.pos] == '.':
          self.pos = self.pos + 1
          buffer2 = "0."
          while self.linha[self.pos].isdigit():
            buffer2 = buffer2 + self.linha[self.pos]
            self.pos = self.pos + 1
          buffer = buffer + float(buffer2)
          tipo = 1 #Configurando o tipo do token para ponto flutuante
        else:
          tipo = 0 #Configurando o tipo do token para inteiro
      else:
        flag = 1
        if self.seOperador(self.linha[self.pos]) != -1:
          flagOp = self.seOperador(self.linha[self.pos])
          buffer = buffer + self.linha[self.pos]
          if self.linha[self.pos] == '"':
            flag = -1
            tipo = 77 #Este tipo de token é uma String
          self.pos = self.pos + 1
          if self.tamLinha > self.pos:
            if flagOp != 0:
              while self.seOperador(self.linha[self.pos]) == flag:
                buffer = buffer + self.linha[self.pos]
                self.pos = self.pos + 1
              if flag == -1:
                if self.linha[self.pos] != '"':
                  while self.linha[self.pos] != '"':
                    buffer = buffer + self.linha[self.pos]
                    self.pos = self.pos + 1
                buffer = buffer + self.linha[self.pos]
                self.pos = self.pos + 1
              if buffer == "//" or buffer == "/":
                tipo = -1
                while self.pos <= self.tamLinha-1:
                  self.pos += 1
                if buffer == "/":
                  self.linha = self.arquivo.readline()
                  while self.linha.find("*/")==-1:
                    self.linha = self.arquivo.readline()
          if tipo != -1 and tipo != 77:
            tipo = 3 #Configurando o tipo do token para Operadores
        else:
          if self.linha[self.pos].isalnum():
            while self.linha[self.pos].isalnum():
              buffer = buffer + self.linha[self.pos]
              self.pos = self.pos + 1
          else:
            tipo = -1
      if tipo != 0 and tipo != 1:
        buffer.replace("\n", "")
      if tipo != -1:
        #print("criar Token:"+str(buffer)+":"+str(tipo))
        token = Token(buffer, tipo)
      else:
        token = self.tokenVazio
        self.flagEOL = 1
        self.linhaAtual += 1
      if tipo == 0 or tipo == 1:
        buffer = ""
      if self.tamLinha-1 <= self.pos:
        self.flagEOL = 1
        self.linhaAtual += 1
        #print(self.linhaAtual)
      return token
    return Token("EOF", 999)

  def seOperador(self, caractere):
    if '=<>|&!"/'.find(caractere) != -1:
      return 1
    else:
      if '+-*/()[]%{},;'.find(caractere) != -1:
        return 0
      return -1

class error():
  def __init__(self):
    self.errors = {
        "59" : "Ponto e vírgula não colocado",
        "40" : "Parenteses não abertos",
        "41" : "Parenteses não fechados",
        "91" : "Colchetes não abertos",
        "93" : "Colchetes não fechados",
        "123": "Chaves não foram abertas",
        "125" : "Chaves não foram fechadas",
        "256" : "Esperava-se uma String",
        "257" : "Esperava-se um maior ou igual (>=)",
        "258" : "Esperava-se um menor ou igual (<=)",
        "259" : "Esperava-se um operador de comparação (==)",
        "260" : "Esperava-se um operador de diferença (!=)",
        "261" : "Esperava-se um inteiro escrito corretamente",
        "262" : "Esperava-se um número decimal escrito corretamente",
        "263" : "Esperava-se uma palavra reservada escrita corretamente",
        "264" : "Nome de variável não aceito",
        "300" : "Erro na memória, árvore sintática não está correta",
        "301" : "Erro de compilação ao salvar tipo de função",
        "302" : "Tentativa de criar um vetor com um número não inteiro de elementos",
        "303" : "Tentativa de um não literal se passar por um valor literal",
        "304" : "Tentativa de chamar função com o número errado de parâmetros",
        "305" : "Tentativa de operação com tipos de dados diferentes",
        "306" : "Tipo de retorno da função não condiz com tipo da função",
        "307" : "Numero de variáveis fornecidas no print não é condizente com o número de variáveis chamadas na String",
        "308" : "Tipo de variável não reconhecida no Scanf",
        "309" : "Tentativa de acessar valor de variável não declarada anteriormente",
        "310" : "Tentativa de entrar na função com o tipo errado de argumento"
    }

  def error(self, number):
    if number < 300:
      print("Erro sintático:"+self.errors[str(number)])
    else:
      print("Erro semântico:"+self.errors[str(number)])
      try:
        os.remove('compillated.c')
      except:
        pass
      try:
        os.remove('main.c')
      except:
        pass
    exit()

class no():
  def __init__(self, token, proximo=None):
    self.token = token
    self.prox = proximo
    self.pai = None
    self.filhos = []

  def setPai(self, pai):
    self.pai = pai

  def addFilho(self, filho):
    self.filhos.append(filho)

  def toString(self):
    print(self.token.valor)

class Pilha():
  def __init__(self):
    self.tamanho = 0
    self.topo = None

  def vazio(self):
    if self.topo == None:
      return 1
    return 0

  def empilha(self, no):
    no.prox = self.topo
    self.topo = no
    self.tamanho +=1

  def pop(self, number=1):
    for n in range(number):
      if not self.vazio():
        aux = self.topo
        print(aux.token.valor)
        self.topo = aux.prox
        self.tamanho -= 1
        return aux;
      else:
        print("Pilha vazia")
        return -1

  def esvazia(self):
    while not self.vazio():
      self.pop()

class Arvore():
  def __init__(self):
    self.Raiz = None

  def Terminal(self, aux , prefixo=""):
    ponteiro = ""
    segmento = ""
    if aux.pai == None:
      print(aux.token.valor)
    else:
      if aux.pai != None and aux.pai.filhos[-1] != aux:
        ponteiro = "├── ";
        segmento = "│   ";
      else:
        ponteiro = "└── ";
        segmento = "    ";

    print(prefixo + ponteiro + str(aux.token.valor)+":"+str(aux.token.tipo))

    N_prefixo = prefixo + segmento

    for nos in aux.filhos:
        self.Terminal(nos, N_prefixo)

  def toString(self):
    self.Terminal(self.Raiz)

class TabelaDeSimbolos():
  def __init__(self, ident):
    self.ident = ident.lower()
    self.prox_tabela = None
    self.tabela_filha = []
    self.dicionario = dict()

  def register(self, chave, tipo):
    self.dicionario.setdefault(chave, tipo)

  def getReg(self, chave):
    return self.dicionario.get(chave)

  def setFilha(self, novaTabela):
    self.tabela_filha.append(novaTabela)

  def setPai(self, tabela):
    self.prox_tabela = tabela

  def getTab(self,ident):
    for tabela in self.tabela_filha:
      if ident == tabela.ident:
        return tabela

  def dictToString(self):
    for d in self.dicionario:
      print(str(d) + ":" + str(self.dicionario[d]))

  def toString(self):
    print(self.ident+"{")
    self.dictToString()
    for filho in self.tabela_filha:
      filho.toString()
    print("}")

class parser():
  def __init__(self, nomeArquivo):
    self.bufferID = ""
    self.bufferTipo = ""
    self.bufferIdent = ""
    self.errors = error()
    self.pilha = Pilha()
    self.Tabela_de_Simbolos = TabelaDeSimbolos("global")
    self.arvore = Arvore()
    self.lex = lexicografo(nomeArquivo)
    self.lookahead = self.lex.scan()
    self.declaracao_algoritmo()

  def match(self, token, node): ##
    #print(self.lookahead.valor)
    if token == self.lookahead.tipo:
      nof = no(self.lookahead)
      nof.setPai(node)
      node.addFilho(nof)
      self.pilha.empilha(nof)
      self.lookahead = self.lex.scan()
      #print(self.lookahead.toString())
      while self.lookahead.tipo == -1:
        self.lookahead = self.lex.scan()
    else:
      print("Erro de Sintaxe na linha", self.lex.getLinhaAtual()+1, self.lookahead.toString())
      self.errors.error(token)
      #self.pilha.esvazia()
      #exit()

  def lvalue(self, node, flag=0): ## lvalue -> 264 ("[" expressao "]")*;
    aux = no(Token("lvalue", -1, 1))
    node.addFilho(aux)
    aux.setPai(node)
    if flag == 0:
      if self.Tabela_de_Simbolos.getReg(self.lookahead.valor.lower()) == None:
          self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), self.bufferTipo)
      self.match(264, aux)
    else:
      nof = no(self.bufferID)
      aux.addFilho(nof)
      nof.setPai(aux)
    while self.lookahead.tipo == 91:
      self.match(91, aux)
      self.expressao(aux)
      self.match(93, aux)
    self.pilha.empilha(aux)

  def linha_lista(self, node): ## linha_lista -> linha_atribuicao | funcao_chamar ";"| linha_retorno | linha_se | linha_enquanto | linha_para;
    #print(self.lookahead.valor.lower())
    if self.lookahead.valor.lower() == "para":
      aux = no(Token("linha_lista", -2, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.linha_para(aux)
      self.pilha.empilha(aux)
    else:
      if self.lookahead.valor.lower() == "enquanto":
        aux = no(Token("linha_lista", -2, 1))
        node.addFilho(aux)
        aux.setPai(node)
        self.linha_enquanto(aux)
        self.pilha.empilha(aux)
      else:
        if self.lookahead.valor.lower() == "se":
          aux = no(Token("linha_lista", -2, 1))
          node.addFilho(aux)
          aux.setPai(node)
          self.linha_se(aux)
          self.pilha.empilha(aux)
        else:
          if self.lookahead.valor.lower() == "retorne":
            aux = no(Token("linha_lista", -2, 1))
            node.addFilho(aux)
            aux.setPai(node)
            self.linha_retorno(aux)
            self.pilha.empilha(aux)
          else:
            if self.lookahead.tipo == 264:
              aux = no(Token("linha_lista", -2, 1))
              node.addFilho(aux)
              aux.setPai(node)
              if(self.funcao_chamar(aux)!=-1):
                self.match(59, aux)
                self.pilha.empilha(aux)
              else:
                #print("Linha Atrib")
                self.linha_atribuicao(1, aux)
                self.pilha.empilha(aux)

  def linha_atribuicao(self, number, node): ## linha_atribuicao -> lvalue "=" expressao ";";
    aux = no(Token("linha_atribuicao", -3, 1))
    node.addFilho(aux)
    aux.setPai(node)
    self.lvalue(aux, number)
    self.match(61, aux)
    self.expressao(aux)
    if number != 0:
      self.match(59, aux)
    self.pilha.empilha(aux)

  def linha_se(self, node): ## linha_se -> "se" expressao 123 linha_lista 125 ("senão" 123 linha_lista 125)?;
    if self.lookahead.tipo == 263:
      aux = no(Token("linha_se", -4, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(263, aux)
      self.expressao(aux)
      self.match(123, aux)
      self.linha_lista(aux)
      self.match(125, aux)
      self.pilha.empilha(aux)
    if self.lookahead.tipo == 263 and self.lookahead.valor.lower() == "senao":
      aux = no(Token("linha_se", -4, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(263, aux)
      self.match(123, aux)
      self.linha_lista(aux)
      self.match(125, aux)
      self.pilha.empilha(aux)

  def linha_para(self, node): ## linha_para -> "para" 40 linha_atribuicao 59 expressao 59 linha_atribuicao 41 123 linha_lista 125;
    if self.lookahead.tipo == 263:
      aux = no(Token("linha_para", -5, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(263, aux)
      self.match(40, aux)
      if self.lookahead.tipo != 59:
        self.linha_atribuicao(0, aux)
      self.match(59, aux)
      if self.lookahead.tipo != 59:
        self.expressao(aux)
      self.match(59, aux)
      if self.lookahead.tipo != 41:
        self.linha_atribuicao(0, aux)
      self.match(41, aux)
      self.match(123, aux)
      self.linha_lista(aux)
      self.match(125, aux)
      self.pilha.empilha(aux)

  def linha_retorno(self, node): ## linha_retorno -> "retorne" expressao? ";";
    if self.lookahead.tipo == 263:
      aux = no(Token("linha_retorno", -6, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(263, aux)
      if self.lookahead.tipo != 59:
        self.expressao(aux)
      self.match(59, aux)
      self.pilha.empilha(aux)

  def linha_enquanto(self, node): ## linha_enquanto -> "enquanto" 40 expressao 41 123 linha_lista 125;
    if self.lookahead.tipo == 263:
      aux = no(Token("linha_enquanto", -7, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(263, aux)
      self.match(40, aux)
      self.expressao(aux)
      self.match(41, aux)
      self.match(123, aux)
      while self.lookahead.tipo != 125:
        self.linha_lista(aux)
      self.match(125, aux)
      self.pilha.empilha(aux)

  def tipo_primitivo(self, node): ## tipo_primitivo -> 263;
    if self.lookahead.tipo == 263:
      aux = no(Token("tipo_primitivo", -8, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.bufferTipo = self.lookahead.valor.lower()
      self.match(263, aux)
      self.pilha.empilha(aux)

  def funcao_parametro(self, node): ## funcao_parametro -> tipo_primitivo 264;
    aux = no(Token("funcao_parametro", -9, 1))
    node.addFilho(aux)
    aux.setPai(node)
    self.tipo_primitivo(aux)
    self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), self.bufferTipo)
    self.match(264, aux)
    self.pilha.empilha(aux)

  def funcao_parametros(self, node): ## funcao_parametros -> funcao_parametro (<44> funcao_parametro)*;
    aux = no(Token("funcao_parametros", -10, 1))
    node.addFilho(aux)
    aux.setPai(node)
    self.funcao_parametro(aux)
    cont = 1
    while self.lookahead.tipo == 44:
      self.match(44, aux)
      self.funcao_parametro(aux)
      cont+=1
    self.Tabela_de_Simbolos.register("numPam", cont)
    self.pilha.empilha(aux)

  def funcao_argumentos(self, node): ## funcao_argumentos -> expressao ("," expressao)*;     _____ Quando chama a função
    aux = no(Token("funcao_argumentos", -11, 1))
    node.addFilho(aux)
    aux.setPai(node)
    self.expressao(aux)
    while self.lookahead.tipo == 44:
      self.match(44, aux)
      self.expressao(aux)
    self.pilha.empilha(aux)

  def funcao_chamar(self, node): ## funcao_chamar -> 264 "(" funcao_argumentos? ")";
    if self.lookahead.tipo == 264:
      aux = no(Token("funcao_chamar", -12, 1))
      self.bufferID = self.lookahead
      self.match(264, aux)
      if self.lookahead.tipo == 40:
        node.addFilho(aux)
        aux.setPai(node)
        self.match(40, aux)
      else:
        return -1
      if self.lookahead.tipo != 41:
        self.funcao_argumentos(aux)
      self.match(41, aux)
      self.pilha.empilha(aux)

  def literais(self, node): ## literais -> 261 | 262 | 256;
    if self.lookahead.tipo == 261:
      aux = no(Token("literais", -13, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(261, aux)
      self.pilha.empilha(aux)
    else:
      if self.lookahead.tipo == 262:
        aux = no(Token("literais", -13, 1))
        node.addFilho(aux)
        aux.setPai(node)
        self.match(262, aux)
        self.pilha.empilha(aux)
      else:
        if self.lookahead.tipo == 256:
          aux = no(Token("literais", -13, 1))
          node.addFilho(aux)
          aux.setPai(node)
          self.match(256, aux)
          self.pilha.empilha(aux)

  def declaracao_variaveis(self, node): ## declaracao_variaveis -> tipo_primitivo 264 (("," 264)*| ("[" literais "]")*)*";";
    aux = no(Token("declaracao_variaveis", -14, 1))
    node.addFilho(aux)
    aux.setPai(node)
    self.tipo_primitivo(aux)
    self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), self.bufferTipo)
    self.match(264, aux)
    while self.lookahead.tipo == 44 or self.lookahead.tipo == 91:
      if self.lookahead.tipo == 44:
        self.match(44, aux)
        self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), self.bufferTipo)
        self.match(264, aux)
      else:
        self.match(91, aux)
        self.literais(aux)
        self.match(93, aux)
    self.match(59, aux)
    self.pilha.empilha(aux)

  def Add(self, node): ## Add - > "|" expressao Add | "&" expressao  Add | ("=") expressao Add | (">"|">="|"<"|"<="|"=="|"!=") expressao Add
  # | ("+" | "-") expressao Add | ("/"|"*"|"%") expressao Add | lambda;
    flag = 0
    aux = None
    if self.lookahead.tipo == 124: # "|"
      aux = no(Token("Add", -15, 1))
      node.addFilho(aux)
      aux.setPai(node)
      flag = 10
      self.match(124, aux)
    else:
      if self.lookahead.tipo == 38: # "&"
        aux = no(Token("Add", -15, 1))
        node.addFilho(aux)
        aux.setPai(node)
        flag = 10
        self.match(38, aux)
      else:
        if self.lookahead.tipo == 61: # ("=")
          aux = no(Token("Add", -15, 1))
          node.addFilho(aux)
          aux.setPai(node)
          flag = 10
          self.match(61, aux)
        else:
          if self.lookahead.tipo == 62 or self.lookahead.tipo == 257 or self.lookahead.tipo == 60 or self.lookahead.tipo == 258 or self.lookahead.tipo == 259 or self.lookahead.tipo == 260:
          # (">"|">="|"<"|"<="|"=="|"!=")
            aux = no(Token("Add", -15, 1))
            node.addFilho(aux)
            aux.setPai(node)
            flag = 10
            if self.lookahead.tipo == 62:
              self.match(62, aux)
            else:
              if self.lookahead.tipo == 257:
                self.match(257, aux)
              else:
                if self.lookahead.tipo == 60:
                  self.match(60, aux)
                else:
                  if self.lookahead.tipo == 258:
                    self.match(258, aux)
                  else:
                    if self.lookahead.tipo == 259:
                     self.match(259, aux)
                    else:
                      if self.lookahead.tipo == 260:
                        self.match(260, aux)
          else:
            if self.lookahead.tipo == 43 or self.lookahead.tipo == 45: # ("+" | "-")
              aux = no(Token("Add", -15, 1))
              node.addFilho(aux)
              aux.setPai(node)
              flag = 10
              if self.lookahead.tipo == 43:
                if self.Tabela_de_Simbolos.getReg(self.lookahead.valor.lower()) == None:
                    self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), "sum")
                self.match(43, aux)
              else:
                if self.Tabela_de_Simbolos.getReg(self.lookahead.valor.lower()) == None:
                    self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), "sub")
                self.match(45, aux)
            else:
              if self.lookahead.tipo == 47 or self.lookahead.tipo == 42 or self.lookahead.tipo == 37: # ("/"|"*"|"%")
                aux = no(Token("Add", -15, 1))
                node.addFilho(aux)
                aux.setPai(node)
                flag = 10
                if self.lookahead.tipo == 47:
                  if self.Tabela_de_Simbolos.getReg(self.lookahead.valor.lower()) == None:
                    self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), "div")
                  self.match(47, aux)
                else:
                  if self.lookahead.tipo == 42:
                    if self.Tabela_de_Simbolos.getReg(self.lookahead.valor.lower()) == None:
                      self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), "mult")
                    self.match(42, aux)
                  else:
                    if self.Tabela_de_Simbolos.getReg(self.lookahead.valor.lower()) == None:
                      self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), "rest")
                    self.match(37, aux)

    if flag == 10: # expressao Add
      self.expressao(aux)
      self.Add(aux)
    else: # Lambda
      return
    self.pilha.empilha(aux)

  def termo(self, node): ## termo -> funcao_chamar | lvalue | literais | "(" expressao ")";
    if self.lookahead.tipo == 40:
      aux = no(Token("termo", -16, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(40, aux)
      self.expressao(aux)
      self.match(41, aux)
      self.pilha.empilha(aux)
    else:
      aux = no(Token("termo", -16, 1))
      node.addFilho(aux)
      aux.setPai(node)
      if self.lookahead.tipo == 264:
        if self.funcao_chamar(aux) == -1:
          self.lvalue(aux, 1)
          self.pilha.empilha(aux)
          return
        else:
          self.pilha.empilha(aux)
          return
      self.literais(aux)
      self.pilha.empilha(aux)

  def expressao(self, node): ## expressao - > ("+"|"-"|"!")? termo Add;
    aux = no(Token("expressao", -17, 1))
    node.addFilho(aux)
    aux.setPai(node)
    if self.lookahead.tipo == 43:
      if self.Tabela_de_Simbolos.getReg(self.lookahead.valor.lower()) == None:
        self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), "sum")
      self.match(43, aux)
    else:
      if self.lookahead.tipo == 45:
        if self.Tabela_de_Simbolos.getReg(self.lookahead.valor.lower()) == None:
          self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), "sub")
        self.match(45, aux)
      else:
        if self.lookahead.tipo == 33:
          if self.Tabela_de_Simbolos.getReg(self.lookahead.valor.lower()) == None:
            self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), "not")
          self.match(33, aux)
    self.termo(aux)
    self.Add(aux)
    self.pilha.empilha(aux)

  def funcao_declaracao_variaveis(self, node): ## funcao_declaracao_variaveis -> "{" (declaracao_variaveis)*;
    if self.lookahead.tipo == 123:
      aux = no(Token("funcao_declaracao_variaveis", -18, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(123, aux)
      if self.lookahead.tipo == 263 and (self.lookahead.valor.lower() == "inteiro" or self.lookahead.valor.lower() == "flut" or self.lookahead.valor.lower() == "cadeia"):
        while self.lookahead.tipo == 263 and (self.lookahead.valor.lower() == "inteiro" or self.lookahead.valor.lower() == "flut" or self.lookahead.valor.lower() == "cadeia"):
          self.declaracao_variaveis(aux)
        self.pilha.empilha(aux)
      return 1

  def declaracao_variaveis_bloco(self, node): ## declaracao_variaveis_bloco -> 263 123  declaracao_variaveis* 125;
    if self.lookahead.tipo == 263:
      aux = no(Token("declaracao_variaveis_bloco", -19, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(263, aux)
      self.match(123, aux)
      while self.lookahead.tipo != 125:
        self.declaracao_variaveis(aux)
      self.match(125, aux)
      self.pilha.empilha(aux)
    else:
      return

  def linha_bloco(self, node, number=0): ## linha_bloco -> 123 (linha_lista)* 125;
    aux = no(Token("linha_bloco", -20, 1))
    node.addFilho(aux)
    aux.setPai(node)
    if number == 0:
      self.match(123, aux)
    while self.lookahead.tipo != 125:
      self.linha_lista(aux)
    self.match(125, aux)
    self.pilha.empilha(aux)

  def funcao_declaracao(self, node): # funcao_declaracao ->  "função" tipo_primitivo 264 "(" funcao_parametros? ")" funcao_declaracao_variaveis linha_bloco;
    #print("FF"+self.lookahead.valor.lower())
    if self.lookahead.tipo == 263:
      aux = no(Token("funcao_declaracao", -21, 1))
      node.addFilho(aux)
      aux.setPai(node)
      self.match(263, aux)
      self.tipo_primitivo(aux)
      self.Tabela_de_Simbolos.register(self.lookahead.valor.lower(), self.bufferTipo)
      TabAux = TabelaDeSimbolos(self.lookahead.valor.lower())
      self.Tabela_de_Simbolos.setFilha(TabAux)
      TabAux.setPai(self.Tabela_de_Simbolos)
      self.Tabela_de_Simbolos = TabAux
      self.match(264, aux)
      self.match(40, aux)
      if self.lookahead.tipo != 41:
        self.funcao_parametros(aux)
      self.match(41, aux)
      self.linha_bloco(aux, self.funcao_declaracao_variaveis(aux))
      self.pilha.empilha(aux)
      self.Tabela_de_Simbolos = self.Tabela_de_Simbolos.prox_tabela

  def declaracao_algoritmo(self): # declaracao_algoritmo -> 263 123 (declaracao_variaveis_bloco)? linha_bloco (funcao_declaracao)* 125;
    aux = no(Token("declaracao_algoritmo", -22, 1))
    vazio = no(Token("vazio", -99, 1))
    if self.lookahead.tipo == 263:
      self.match(263, vazio)
      self.match(123, aux)
      self.declaracao_variaveis_bloco(aux)
      self.linha_bloco(aux)
      while self.lookahead.tipo != 125:
        self.funcao_declaracao(aux)
      self.match(125, aux)
      self.pilha.empilha(aux)

    self.arvore.Raiz = aux

class semantic():
  def __init__(self, table, arvore):
    self.incluir = ["stdio.h", "stdlib.h", "string.h"]
    self.arquivoC = open('compillated.c', 'w+')
    self.Tabela_de_Simbolos = table
    self.Tabela_de_SimbolosAUX = None
    self.flagPrint = 0
    self.flagScanf = 0
    self.printArgs = 0
    self.arvore = arvore
    self.error = error()
    self.pilha = Pilha()
    self.analiseSemantica()
    with open('compillated.c', 'r') as file:
      line = file.readline()
      while line:
        self.arquivoC.write(line)
        line = file.readline()
      file.close()
    self.arquivoC.close()
    os.remove('compillated.c')

  def analiseSemantica(self):
    RAIZ = self.arvore.Raiz
    if RAIZ.token.tipo != -22:
      self.error.error(300)
      return -1
    self.declaracaoAlgoritmo(RAIZ)

  def termo(self,node): ## -> funcao_chamar | lvalue | literais | "(" expressao ")";
    bufferVet = None
    for filhos in node.filhos:
      if filhos.token.tipo<0:
        if filhos.token.tipo == -17:#expressao
          bufferVet = self.expressao(filhos, 0)
        elif filhos.token.tipo == -12:#funcao_chamar
          bufferVet = self.funcaoChamar(filhos)
        elif filhos.token.tipo == -1:#lvalue
          bufferVet = self.lvalue(filhos, 0)
        elif  filhos.token.tipo == -13:#literais
          bufferVet = self.literais(filhos)
    return bufferVet

  def tipoDado(self, dado):
    if dado == "inteiro" or dado == 261:
      return 261
    if dado == "flut" or dado == 262:
      return 262
    if dado == "cadeia" or dado == 256:
      return 256

  def Add(self, node): ## - > "|" expressao Add | "&" expressao  Add | ("=") expressao Add | (">"|">="|"<"|"<="|"=="|"!=") expressao Add | ("+" | "-") expressao Add | ("/"|"*"|"%") expressao Add | lambda;
    buffer = None
    buffer2 = None
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -15:#Add
          if buffer == None:
            buffer = self.Add(filhos)
          else:
            if buffer != None and buffer2 == None:
              buffer2 = self.Add(filhos)
        elif filhos.token.tipo == -17:#expressao
          if buffer == None:
            buffer = self.expressao(filhos, 0)
          else:
            if buffer != None and buffer2 == None:
              buffer2 = self.expressao(filhos, 0)
      else:
        if filhos.token.valor == "|" or filhos.token.valor == "&":
          if filhos.token.valor == "|":
            self.arquivoC.write("||")
          else:
            self.arquivoC.write("&&")
        else:
          self.arquivoC.write(filhos.token.valor)
    if buffer !=None or buffer2 != None:
      if (self.tipoDado(buffer) == self.tipoDado(buffer2)) or ((self.tipoDado(buffer)==261 and self.tipoDado(buffer2)==262) or (self.tipoDado(buffer)==262 and self.tipoDado(buffer2)==261)):
        if self.tipoDado(buffer) == 262:
          return buffer
        else:
          return buffer2
      else:
        if buffer == None and buffer2 != None:
          return buffer2
        else:
          if buffer != None and buffer2 == None:
            return buffer
        self.error.error(305)

  def expressao(self,node, number=0): ## expressao - > ("+"|"-"|"!")? (termo) (Add);
    buffer1 = None
    buffer2 = None
    for filhos in node.filhos: ##Se number == 0, quer dizer que fará comparação de tipos, se igual a 1, verificará se o tipo de retorno condiz com a função.
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -15:#Add
          if buffer1 == None:
            buffer1 = self.Add(filhos)
          else:
            if buffer1 != None and buffer2 == None:
              buffer2 = self.Add(filhos)
        elif filhos.token.tipo == -16:#termo
          if buffer1 == None:
            buffer1 = self.termo(filhos)
          else:
            if buffer1 != None and buffer2 == None:
              buffer2 = self.termo(filhos)
      else:
        self.arquivoC.write(filhos.token.valor)
    if buffer1 != None and buffer2 != None:
      #print("Chegou")
      if (self.tipoDado(buffer1) == self.tipoDado(buffer2)) or ((self.tipoDado(buffer1)==261 and self.tipoDado(buffer2)==262) or (self.tipoDado(buffer1)==262 and self.tipoDado(buffer2)==261)):
        if self.tipoDado(buffer1)==262:
          return buffer1
        else:
          return buffer2
      else:
        print("Buffer1"+str(buffer1) + "Buffer2"+str(buffer2))
        self.error.error(305)
    else:
      if number == 0:
        if buffer1 == None and buffer2 != None:
          return buffer2
        else:
          if buffer1 != None and buffer2 == None:
            return buffer1
      else:
        if self.pilha.topo != None:
          if buffer1 != None:
            if self.tipoDado(buffer1) == self.tipoDado(self.pilha.topo.token.valor):
              self.pilha.pop()
              return buffer1
            else:
              print(str(self.pilha.topo.token.valor))
              print("Buffer0"+str(self.tipoDado(buffer1))+ "Topo"+str(self.tipoDado(self.pilha.topo.token.valor)))
              self.error.error(306)
          else:
            if buffer2 != None:
              if self.tipoDado(buffer2) == self.tipoDado(self.pilha.topo.token.valor):
                self.pilha.pop()
                return buffer1
            else:
              print("Buffer"+str(self.tipoDado(buffer2))+ "Topo"+str(self.tipoDado(self.pilha.topo.token.valor)))
              self.error.error(306)

  def lvalue(self,node, number=0): ## -> 264 ("[" expressao "]")*; #Se number == 1, quer dizer que a linha atribuição requisita comparação de tipos
    for filhos in node.filhos:
      if number == 1:
        if filhos.token.tipo == -17:#expressao
          self.expressao(filhos)
        if filhos.token.tipo == 264:
          self.arquivoC.write(filhos.token.valor)
          return self.Tabela_de_Simbolos.getReg(filhos.token.valor.lower())
      else:
        if filhos.token.tipo == -17:#expressao
          self.expressao(filhos)
        if filhos.token.tipo == 264:
          if self.flagScanf == 1:
            if self.tipoDado(self.Tabela_de_Simbolos.getReg(filhos.token.valor.lower())) == 256:
              self.arquivoC.write('char teclado[BUFSIZ]; setbuf(stdin, teclado); fgets(teclado, BUFSIZ, stdin);'+filhos.token.valor+'= teclado')
            elif self.tipoDado(self.Tabela_de_Simbolos.getReg(filhos.token.valor.lower())) == 261:
              self.arquivoC.write('"%d", &'+filhos.token.valor)
            elif self.tipoDado(self.Tabela_de_Simbolos.getReg(filhos.token.valor.lower())) == 262:
              self.arquivoC.write('"%f", &'+filhos.token.valor)
            else:
              self.error.error(308)
            self.flagScanf = 0
          else:
            variavel = self.Tabela_de_Simbolos.getReg(filhos.token.valor.lower())
            if variavel == None:
              print("Variavel "+filhos.token.valor.lower()+" Não declarada!")
              self.error.error(309)
            else:
              self.arquivoC.write(filhos.token.valor)
              return variavel

  def declaracaoVariaveisBloco(self, node): ## -> 263 123  declaracao_variaveis* 125;
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -14:#declaracao_variaveis
          self.declaracaoVariaveis(filhos)

  def tipoPrimitivo(self, node): ##  -> 263;
    bufferTipo = ""
    for filhos in node.filhos:
      if filhos.token.valor == "inteiro":
        bufferTipo = "int"
      elif filhos.token.valor == "flut":
        bufferTipo = "float"
      elif filhos.token.valor == "cadeia":
        bufferTipo = "char*"
      self.arquivoC.write(bufferTipo+" ")
      return filhos.token.valor

  def linhaAtribuicao(self,node): ## -> (lvalue) "=" (expressao) ";";
    buffer1 = None
    buffer2 = None
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -1:#lvalue
          buffer1 = self.lvalue(filhos)
        elif filhos.token.tipo == -17:#expressao
          buffer2 = self.expressao(filhos)
      else:
          if buffer1 != None and buffer2 != None:
            if (self.tipoDado(buffer1) == self.tipoDado(buffer2)) or (self.tipoDado(buffer1)==262 and self.tipoDado(buffer2)==261):
              self.arquivoC.write(filhos.token.valor)
            else:
              print("buf1"+str(buffer1)+"buff2"+str(buffer2))
              self.error.error(305)
          else:
            self.arquivoC.write(filhos.token.valor)


  def funcaoArgumentos(self, node, number=0): ## -> (expressao) ("," expressao)*;
    cont = 0
    bufferT = []
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -17:#expressao
          bufferT.append(self.expressao(filhos))
          cont += 1
      else:
        self.arquivoC.write(filhos.token.valor)
    if number == 1:
      if self.flagPrint == 1:
        self.flagPrint = 0
        if(self.printArgs != cont-1) and cont-1 != 0:
          print("Args da string"+str(self.printArgs)+"Contagem"+str(cont-1))
          self.error.error(307)
        self.printArgs = 0
      if self.flagScanf == 1:
        self.flagScanf = 0
    else:
      if self.Tabela_de_SimbolosAUX != None:
        if cont != self.Tabela_de_SimbolosAUX.getReg("numPam"):
          self.error.error(304)
        else:
          i = 0
          for nomes in self.Tabela_de_SimbolosAUX.dicionario:
            if self.tipoDado(bufferT[i]) != self.tipoDado(self.Tabela_de_SimbolosAUX.getReg(nomes)):
              self.error.error(310)
            if i == cont-1:
              break
            i += 1
      else:
        self.error.error(301)

  def funcaoChamar(self,node): ## -> 264 "(" (funcao_argumentos?) ")";
    NomeBuffer = ""
    flagEscreval = 0
    flag = 0
    flagScanf = 0
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -11:#funcao_argumentos
          if NomeBuffer != "escreva" and NomeBuffer != "leia" and NomeBuffer != "escreval":
            self.funcaoArgumentos(filhos)
          else:
            self.funcaoArgumentos(filhos, 1)
      else:
        if filhos.token.tipo==264:
          NomeBuffer = filhos.token.valor
          if NomeBuffer != "escreva" and NomeBuffer != "leia" and NomeBuffer != "escreval":
            if self.Tabela_de_SimbolosAUX == None:
              self.Tabela_de_SimbolosAUX = self.Tabela_de_Simbolos.getTab(NomeBuffer.lower())
            self.arquivoC.write(filhos.token.valor+"(")
            flag = 1
          else:
            if NomeBuffer == "escreva" or NomeBuffer == "escreval":
              if NomeBuffer == "escreval":
                flagEscreval = 1
              self.arquivoC.write("printf(")
              self.flagPrint = 1
            else:
              flagScanf = 1
              self.flagScanf = 1
    if flag ==1:
      self.arquivoC.write(")")
      self.Tabela_de_SimbolosAUX = None
      return self.Tabela_de_Simbolos.getReg(NomeBuffer)
    if flagScanf == 0:
      self.arquivoC.write(")")
      flagScanf = 0
    if flagEscreval == 1:
      self.arquivoC.write(';printf("\\n")')

  def linhaRetorno(self,node): ## -> ("retorne") (expressao?) (";");
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -17:#expressao
          self.expressao(filhos, 1)
      else:
        if filhos.token.tipo==263:
          self.arquivoC.write("return ")
        else:
          self.arquivoC.write(filhos.token.valor)

  def linhaSe(self,node): ## -> ("se" )(expressao) (123) (linha_lista) (125) ("senão" 123 linha_lista 125)?;
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -17:#expressao
          self.expressao(filhos)
          self.arquivoC.write(")")
        elif filhos.token.tipo == -2:#linha_lista
          self.linhaLista(filhos)
      else:
        if filhos.token.tipo==263:
          if filhos.token.valor.lower() == "se":
            self.arquivoC.write("if(")
          else:
            self.arquivoC.write("else")
        else:
          self.arquivoC.write(filhos.token.valor)

  def linhaEnquanto(self,node):## -> "enquanto" 40 (expressao) 41 123 (linha_lista) 125;
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -17:#expressao
          self.expressao(filhos)
        elif filhos.token.tipo == -2:#linha_lista
          self.linhaLista(filhos)
      else:
        if filhos.token.tipo==263:
          self.arquivoC.write("while")
        else:
          self.arquivoC.write(filhos.token.valor)


  def linhaPara(self,node):## -> ("para") (40) (linhaAtribuicao) (59) (expressao) (59) (linha_atribuicao) (41) (123) (linha_lista) (125);
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -3:#linha_atribuicao
          self.linhaAtribuicao(filhos)
        elif filhos.token.tipo == -17:#expressao
          self.expressao(filhos)
        elif filhos.token.tipo == -2:#linha_lista
          self.linhaLista(filhos)
      else:
        if filhos.token.tipo==263:
          self.arquivoC.write("for")
        else:
          self.arquivoC.write(filhos.token.valor)

  def linhaLista(self,node):## -> linha_atribuicao | funcao_chamar ";"| linha_retorno | linha_se | linha_enquanto | linha_para;
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -3:#linha_atribuicao
          self.linhaAtribuicao(filhos)
        elif filhos.token.tipo == -4:#linha_se
          self.linhaSe(filhos)
        elif filhos.token.tipo == -5:#linha_para
          self.linhaPara(filhos)
        elif filhos.token.tipo == -6:#linha_retorno
          self.linhaRetorno(filhos)
        elif filhos.token.tipo == -7:#linha_enquanto
          self.linhaEnquanto(filhos)
        elif filhos.token.tipo == -12:#funcao_chamar
          self.funcaoChamar(filhos)
      else:
        if filhos.token.tipo==59:
          self.arquivoC.write(filhos.token.valor)

  def linhaBloco(self, node): ## -> 123 (linha_lista)* 125;
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -2:#linha_lista
          self.linhaLista(filhos)
      else:
        if filhos.token.tipo==123:
          pass
        else:
          self.arquivoC.write(filhos.token.valor)

  def funcaoParametro(self, node): ## -> tipo_primitivo 264;
    bufferTipo = ""
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -8:#tipo_primitivo
          bufferTipo = self.tipoPrimitivo(filhos)
      else:
        if filhos.token.tipo==264:
          if self.Tabela_de_Simbolos.getReg(filhos.token.valor.lower()) != bufferTipo:
            self.error.error(301)
          else:
            self.arquivoC.write(filhos.token.valor)

  def funcaoParametros(self, node): ## -> funcao_parametro (<44> funcao_parametro)*;
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -9:#funcao_parametro
          self.funcaoParametro(filhos)
      else:
        self.arquivoC.write(filhos.token.valor)
    self.arquivoC.write(')')

  def literais(self, node, number=0): # -> 261 | 262 | 256;
    if number == 2: # QUer dizer que veio da função declaração variáveis
      for filhos in node.filhos:
        if filhos.token.tipo == 261:
          self.arquivoC.write(str(filhos.token.valor))
          return filhos.token.valor
        else:
          self.error.error(302)
    else:
      for filhos in node.filhos:
        if filhos.token.tipo == 261 or filhos.token.tipo == 262 or filhos.token.tipo == 256:
          if filhos.token.tipo == 256:
            if self.flagPrint == 1:
              for i in range(len(filhos.token.valor)):
                if filhos.token.valor[i] == '%':
                  if filhos.token.valor[i+1] == 'i' or filhos.token.valor[i+1] == 'c' or filhos.token.valor[i+1] == 'f' or filhos.token.valor[i+1] == 's' or filhos.token.valor[i+1] == 'd':
                    self.printArgs += 1
                    if filhos.token.valor[i+1] == 'i':
                      filhos.token.valor[i+1].replace('i', 'd')
                    elif filhos.token.valor[i+1] == 'c':
                      filhos.token.valor[i+1].replace('c', 's')
          self.arquivoC.write(str(filhos.token.valor))
          return filhos.token.tipo
        else:
          self.error.error(303)

  def returnPrimitive(self, tipo):
    if tipo == 261:
      return 0
    elif tipo == 262:
      return 0.0
    elif tipo == 256:
      return ""

  def declaracaoVariaveis(self, node): #-> tipo_primitivo 264 (("," 264)*| ("[" literais "]")*)*";";
    bufferTipo = ""
    bufferVar = ""
    bufferVet = []
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -8:#tipo_primitivo
          bufferTipo = self.tipoPrimitivo(filhos)
        elif  filhos.token.tipo == -13:#literais
          bufferVet.append(self.literais(filhos, 2))
      else:
        if filhos.token.tipo==264:
          bufferVar = filhos.token.valor.lower()
          if self.Tabela_de_Simbolos.getReg(filhos.token.valor.lower()) != bufferTipo:
            self.error.error(301)
          self.arquivoC.write(filhos.token.valor)
        else:
          if filhos.token.tipo==44 or filhos.token.tipo==59:
            if len(bufferVet)==0:
              self.Tabela_de_Simbolos.register(bufferVar, {
                  "type":"var",
                  "tipo": bufferTipo,
                  "valor": self.returnPrimitive(bufferTipo)
              })
            else:
              if len(bufferVet)==1:
                self.Tabela_de_Simbolos.register(bufferVar, {
                  "type":"vetor",
                  "tipo": bufferTipo,
                  "valorMax": bufferVet[0],
                  "valor": self.returnPrimitive(bufferTipo)
                })
              elif  len(bufferVet)>1:
                var = {
                        "type":"matriz",
                        "tipo": bufferTipo,
                        "valor": self.returnPrimitive(bufferTipo)
                      }
                for number in bufferVet:
                  var += {"valorMax"+number: number}
                self.Tabela_de_Simbolos.register(bufferVar, var)
          self.arquivoC.write(filhos.token.valor)

  def funcaoDeclaracaoVariaveis(self, node): #-> "{" (declaracao_variaveis)*;
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -14:#declaracao_variaveis
          self.declaracaoVariaveis(filhos)
      else:
        if filhos.token.tipo<255:
          if filhos.token.tipo==123:
            self.arquivoC.write(filhos.token.valor)

  def funcaoDeclaracao(self, node): #->  263 tipo_primitivo 264 "(" funcao_parametros? ")" funcao_declaracao_variaveis linha_bloco;
    flag = False
    bufferTipo = ""
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -8:#tipo_primitivo
          bufferTipo = self.tipoPrimitivo(filhos)
        elif filhos.token.tipo == -10:#funcao_parametros
          self.funcaoParametros(filhos)
          flag = True
        elif filhos.token.tipo == -18:#funcao_declaracao_variaveis
          if not flag:
            self.arquivoC.write(')')
            flag = True
          self.funcaoDeclaracaoVariaveis(filhos)
        elif filhos.token.tipo == -20:#linha_bloco
          if not flag:
            self.arquivoC.write(')')
            flag = True
          self.linhaBloco(filhos)
      else:
        if filhos.token.tipo==263:
          pass
        elif filhos.token.tipo==264 or filhos.token.tipo==29 or filhos.token.tipo==28:
          if filhos.token.tipo==264:
            #print("Função"+filhos.token.valor)
            if self.tipoDado(self.Tabela_de_Simbolos.getReg(filhos.token.valor)) != self.tipoDado(bufferTipo):
              self.error.error(301)
            else:
              self.pilha.empilha(no(Token(bufferTipo, 1, 1)))
            self.Tabela_de_Simbolos = self.Tabela_de_Simbolos.getTab(filhos.token.valor)
          self.arquivoC.write(filhos.token.valor+'(')

  def declaracaoAlgoritmo(self, node): #-> 263 123 (declaracao_variaveis_bloco)? linha_bloco (funcao_declaracao)* 125;
    self.arquivoC.write("void main()")
    flag = False
    for filhos in node.filhos:
      if filhos.token.tipo < 0:
        if filhos.token.tipo == -19:#declaracao_variaveis_bloco
          self.declaracaoVariaveisBloco(filhos)
        elif filhos.token.tipo == -20:#linha_bloco
          self.linhaBloco(filhos)
        elif filhos.token.tipo == -21:#funcao_declaracao
          if not flag:
            self.arquivoC.close()
            self.arquivoC = open('main.c', 'w+')
            for include in self.incluir:
              self.arquivoC.write("#include<"+include+">\n")
            flag = True
          self.funcaoDeclaracao(filhos)
          self.Tabela_de_Simbolos = self.Tabela_de_Simbolos.prox_tabela
      else:
        if filhos.token.tipo<255:
          if filhos.token.tipo==123:
            self.arquivoC.write(filhos.token.valor)
    if not flag:
      self.arquivoC.close()
      self.arquivoC = open('main.c', 'w+')
      for include in self.incluir:
        self.arquivoC.write("#include<"+include+">\n")
      flag = True

flagHello = False
flagMain = None
flagClear = False
Verbose = False
cont = 0
for args in sys.argv:
  if args == '-main':
    flagMain = sys.argv[cont+1]
  if args == '-v':
    Verbose = sys.argv[cont+1]
  if args == '-cls':
    flagClear = True
  if args == '-h':
    flagHello = True
  cont += 1

try:
  if (sys.argv[1]) and not flagHello:
    if(sys.argv[1].find('.cp')!=-1) or (sys.argv[1].find('.txt')!= -1):
      print(sys.argv[1])
      P = parser(sys.argv[1])
    else:
      print("extensão de arquivo não permitida no compilador de CPortugol")
      exit()
  else:
    P = parser('arquivonaoexistente.jkjkjkjl')
except FileNotFoundError:
  print("Arquivo não encontrado!")
  resposta = input("Deseja carregar o arquivo de Hello World? [S/n]")
  if resposta != 'n' and resposta != 'no' and resposta != 'nao' and resposta != 'not' and resposta != 'não': 
    flagHello = True
    with open('HelloWorld.cp', 'w') as file:
      file.writelines("""
      algoritmo{
        variaveis{ //Abre chaves para as variáveis
          inteiro cont;
          flut teste;
          cadeia caractere;
        }

        { //Abre chaves para o código
          escreval("Ola mundo!");
          escreval("Qual e o seu nome?");
          leia(caractere);
          escreval("Seja bem vindo, %s", caractere);
        }
      }""")
      file.close()
      #P.Tabela_de_Simbolos.toString()# __ testa a tabela
      #P.pilha.esvazia() ___ Testa a pilha
    P = parser(r'HelloWorld.cp')
  else:
    exit()
if Verbose == 'y':
  print("="*10+"Tabela de símbolos"+"="*10)
  P.Tabela_de_Simbolos.toString()
  print("="*10+"Arvore"+"="*10)
  P.arvore.toString()

S = semantic(P.Tabela_de_Simbolos, P.arvore)

try:
  open('main.c', 'r').close()
  os.system('gcc main.c -o main.exe')
  os.system('main.exe')
  os.remove('main.exe')
except:
  os.system('gcc compillated.c -o main.exe')
  os.system('main.exe')

try:
  open(r'HelloWorld.cp').close()
  if flagHello:
    resposta = input("Arquivo de HelloWorld encontrado, deseja remover  o arquivo HelloWorld?[S/n]")
    if resposta != 'n' and resposta != 'no' and resposta != 'nao' and resposta != 'not' and resposta != 'não': 
      os.remove('HelloWorld.cp')
except FileNotFoundError:
  pass

try:
  if flagMain != 'y':
    resposta = input("Deseja remover o arquivo main.c?[S/n]")
  else:
    resposta = 'y'
  open(r'main.c').close()
  if (resposta != 'n' and resposta != 'no' and resposta != 'nao' and resposta != 'not' and resposta != 'não'): 
    os.remove('main.c')
except:
  pass

if flagClear == True:
  try:
    os.system('cls')
  except:
    try:
      os.system('clear')
    except:
      exit()